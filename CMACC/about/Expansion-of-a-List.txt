The user imagines that the List is expanded just like the text is expanded:

Expanding the List is like expanding the text, EXCEPT that we have to expand expressions in the List from the top, and we expand an expression only if it might have the key we are looking for.  (In contrast, it does not matter in what order we expand expressions in the text.)  

We start with the List as it is.  We distinguish between the part of the List BEFORE an expression (the FIRST) and the REST.  

We test the key we are looking for against the first key in the FIRST, etc, until found.  If not found, we consider expanding the expression.  We do expand the expression IF the expression MIGHT contain the key we are looking for.  Normally, it might, but disqualifying circumstances are (i) it’s prefix is incompatible or (ii) we’ve already expanded it (e.g., in circular referencing between Lists).

(This explanation can probably be simplified as recursion.)
After expanding the expression, we test the key against it, and recursively expand any expressions in it.  If we find the key, we stop.  If we exhaust the List and expressions, we stop.  We then add the result of the recursive expansion to the FIRST.  If we found the key then we return the value.  If we did not find the key then we continue testing it against the REST. 
 
Prefixes:  When expanding a List, the prefix is added to each key, and to each expression in a value.

Metadata:  When expanding a List, the FIRST must have a record of the source of each included key. I believe that it does not have to have a record of how it was expanded (in contrast to expansion of a text, where the nesting does matter). 

So, trying to make this a flow-chart:


Expanding a List into a Text means replacing the TextExpressions with the value returned by interrogating the List.

TextExpansion begins with an arbitrary Key1 = “Model.Root” and continues until each TextExpression in the expanding text has been replaced or determined to be missing. 

Interrogate List for KeyX:

	For each key/value in List:
		Is the key/value a ListExpression?
			Might it contain a key that matches KeyX?
				If so, 	then Expand the ListExpression and 
					move the pointer to the beginning of the expansion.
				If not, then move on to the next key/value in the List.  
		Does the key match KeyX?
			If so, then return the value.
			If not, then move on to the next key/value in the List. 
		If the List is exhausted and KeyX is not found, 
			then add it as “not found” at the top of the List.

  	Expand the ListExpression:
		Replace the ListExpression with:
			A copy of the referenced List
			In which the Prefix has been added to:
				the beginning of each key and 
				each TextExpression.  
		
